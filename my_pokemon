#! /usr/bin/env python3


"""
Pokemon Database

Written by: <WEIHOU ZENG>
Written on: <12/04/2023>

My Pokemon

Create your very own Pokemon
"""


import sys
import psycopg2
import helpers
from random import Random


### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None


### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret




def main():
    # TODO: YOUR CODE HERE
    try:
        random_float_seed = rng.random()
        with db.cursor() as cur:
            set_seed_query = "SELECT setseed(%s);"
            cur.execute(set_seed_query, (random_float_seed, ))


            for_game_menu = """
            SELECT name, id
            FROM (
            SELECT name, id
            FROM Games
            ORDER BY random()
            LIMIT 10
            ) AS random_games;
            """

            cur.execute(for_game_menu)
            game_options = cur.fetchall()


            game_selected = game_options[menu([row[0] for row in game_options])]


            query_pokemon_menu = """
            SELECT p.name, p.id, p.species, tf.name, ts.name, g.regional_id
            FROM (
            SELECT national_id, game, regional_id
            FROM Pokedex
            WHERE game = %s
            ) AS g
            INNER JOIN Pokemon AS p ON g.national_id = p.id
            LEFT JOIN Types AS tf ON tf.id = p.first_type
            LEFT JOIN Types AS ts ON ts.id = p.second_type
            ORDER BY random()
            LIMIT 10;
            """

            cur.execute(query_pokemon_menu, (game_selected[1], ))
            poke_options = cur.fetchall()


            poke_options_names = [row[0] for row in poke_options]
            selected_index = menu(poke_options_names)
            poke_selected = poke_options[selected_index]
            poke_id = poke_selected[1][1:-1]
            poke_id_split = poke_id.split(',')


            query_poke_ab_menu = """
            SELECT a.name, a.id
            FROM Abilities AS a
            INNER JOIN (
            SELECT knows
            FROM Knowable_Abilities
            WHERE (known_by).Pokedex_Number = %s AND (known_by).Variation_Number = %s
            ) AS k ON a.id = k.knows
            ORDER BY a.id;
            """

            cur.execute(query_poke_ab_menu, (poke_id_split[0], poke_id_split[1]))
            options = cur.fetchall()

            ab_selected = [None] if not options else options[menu([row[0] for row in options])]

            query_poke_moves_menu = """
            SELECT DISTINCT m.name, m.id, t.name, m.category, m.power, m.accuracy
            FROM Moves AS m
            INNER JOIN Learnable_Moves AS l ON m.id = l.Learns
            INNER JOIN Types AS t ON t.id = m.Of_Type
            WHERE (l.Learnt_By).Pokedex_Number = %s
                AND (l.Learnt_By).Variation_Number = %s
                AND l.Learnt_In = %s
                AND l.Learnt_When IN (
                    SELECT r.id
                    FROM Requirements AS r
                    WHERE starts_with(r.Assertion, 'Level:')
                )
            ORDER BY m.id;
            """

            cur.execute(query_poke_moves_menu, (poke_id_split[0], poke_id_split[1], game_selected[1]))
            moves_options = cur.fetchall()


            m_select = []
            while len(m_select) < 4 and moves_options:
                move_names = [row[0] for row in moves_options]
                move_selected = menu(move_names)
                m_select.append(moves_options.pop(move_selected))


            types = [poke_selected[3], poke_selected[4]]
            type_string = f"Type: {types[0]}"
            if types[1]:
                type_string += f" + {types[1]}"
            type_string += "\n"

            # Format and input the collected data into output string
            output = f"""
                Here is your new Pokemon (from Pokemon {game_selected[0]}):
                Name: {poke_selected[0]}
                Species: {poke_selected[2]}
                {type_string}
                Pokedex Number: {poke_selected[5]} ({poke_id_split[0]})
                Ability: {ab_selected[0]}
                Moves:
            """

            output += "\n".join([f"\t{move[0]}\t[{move[2]}]\t(Category: {move[3]}, Power: {move[4]}, Accuracy:{move[5]})" for move in m_select])
            output += "\n"

            print(output)


    except Exception as e:
        print(f"Error: {e}")
        return



if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)
